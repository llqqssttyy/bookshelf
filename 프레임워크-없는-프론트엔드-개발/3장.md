## DOM 이벤트 관리

2장에서는 데이터와 일치하는 DOM 요소를 어떻게 그리는지 알아봤다. 그러나 웹 애플리케이션은 고정된 그림이 아니다. 애플리케이션은 시간이 지남에 따라 변경되고, 이러한 변경을 만드는 것이 이벤트다. 3장의 목적은 프레임워크 없이 이벤트를 관리하는 방법을 이해하는 것이다.

<br/>

### YAGNI 원칙

> **You aren't gonna need it**  
> 당신이 필요하다고 예측할 때가 아니라 실제로 필요할 때 구현하라.

아키텍처를 미리 과도하게 엔지니어링하는 태도는 좋지 않다. 현재는 필요하지 않지만 확장성을 고려해서 미리 작업해 놓으면 코드가 불필요하게 장황해진다. 게다가 설계가 변경되면 너무나 많은 코드를 수정해야 하는 상황이 생긴다.

2장에서 이벤트와 관련한 코드를 고려하지 않은 이유도 이와 같다. **자신만의 아키텍처를 작성할 땐 반드시 YAGNI 원칙을 적용해 당시에 직면한 문제만을 해결해야 한다**.

> **YAGNI** 원칙은 **KISS**, **DRY**와 함께 소프트웨어 개발 3대 원칙으로 여겨진다. KISS는 Keep It Simple and Stupid(Short, Small)의 약자로 코드나 설계 내용이 불필요하게 장황해지는 것을 주의하라는 의미를 담고 있다. DRY는 Do Not Repeat Yourself로 반복되는 코드를 막으라는 뜻이다.

<br/>

### DOM 이벤트 API

이벤트는 웹 애플리케이션에서 발생하는 동작으로, 브라우저는 사용자에게 이를 알려줘 사용자로 하여금 어떤 방식으로든 반응할 수 있게 한다.

브라우저에는 **사용자가 트리거**한 마우스 이벤트, 키보드 이벤트, 뷰 이벤트 등과 **시스템 자체에서 생성**된 네트워크 상태 변화, DOM 콘텐츠 로드 와 같은 이벤트가 있을 수 있다.

이러한 이벤트에 반응하려면 DOM 요소에 이벤트 핸들러를 연결해야 한다.

<br/>

#### 1. 속성에 핸들러 연결하기

이벤트 핸들러를 DOM 요소에 연결하는 직관적이지만 지저분한 방법으로는 `on*` 속성을 사용하는 것이 있다. 하지만 이 방법은 한 번의 하나의 핸들러만 연결할 수 있기 때문에 추천하지 않는다.

```js
const button = document.querySelector('button');
button.onclick = () => {
  console.log('Click');
};
```

#### 2. addEventListener로 핸들러 연결하기

addEventListener를 사용하면 아래와 같이 **필요한 모든 핸들러를 연결할 수 있다**.

```js
const button = document.querySelector('button');
const firstHandler = () => {
  console.log('First');
};
const secondHandler = () => {
  console.log('Second');
};

button.addEventListener('click', firstHandler);
button.addEventListener('click', secondHandler);
```

DOM 요소가 더 이상 존재하지 않으면 메모리 누수를 방지하기 위해 이벤트 리스너도 삭제해야 한다. 이는 removeEventListener를 사용하면 된다.

```js
window.setTimeout(() => {
  button.removeEventListener('click', firstHandler);
  button.removeEventListener('click', secondHandler);
}, 1000);
```

<br/>

### 이벤트 객체

어플리케이션에 전달된 **모든 이벤트는 Event 인터페이스를 구현한다**. 타입에 따라 이벤트 객체는 Event 인터페이스를 확장하는 좀 더 구체적인 Event 인터페이스를 구현할 수도 있다.

예를 들어 click 이벤트는 MouseEvent 인터페이스를 구현한다. MouseEvent 인터페이스는 UIEvent 인터페이스를 확장한 인터페이스이며, UIEvent는 Event 인터페이스를 확장한 인터페이스다.

이러한 Event 계층 구조는 MDN 사이트에서 더 자세하게 확인할 수 있다.

https://developer.mozilla.org/ko/docs/Web/API/Event

<br/>

### DOM 이벤트 라이프사이클

이벤트 리스너의 매개변수를 살펴 보자.

```js
button.addEventListener('click', handler, false);
```

주로 적어주지 않는 3번째 인자는 바로 useCapture 옵션을 의미한다. 해당 옵션은 캡처링을 허용할지 허용하지 않을지를 결정한다. 그렇다면 캡처링이란 무엇일까?

시스템은 \<html\> 태그에서 핸들러 관리를 시작한다. 이벤트가 발생하는 순간 브라우저는 html 태그에서부터 목표 요소까지 이벤트를 이동시키고, 다시 목표 요소에서 html 태그까지 이벤트를 이동시킨다. 이때 하향식 이동을 캡처 단계, 상향식 이동을 버블 단계라고 한다.

1. **캡처 단계**: 이벤트가 html에서 목표 요소로 이동한다.
2. **목표 단계**: 이벤트가 목표 요소에 도달한다.
3. **버블 단계**: 이벤트가 목표 요소에서 html로 이동한다.

useCapture 옵션을 활성화하지 않으면(기본값이 false) 이벤트는 버블 단계에서 처리된다. 즉, 이벤트 핸들러가 상향식으로 실행된다. 반대로 useCapture 옵션을 활성화하면 이벤트 핸들러를 캡처 단계에서 실행시켜 하향식으로 실행한다는 의미가 된다.

일반적으로 버블 단계 핸들러만 사용해도 좋지만 복잡한 상황을 관리하려면 캡처 단계을 알아야 한다.

<br/>

### 사용자 정의 이벤트 사용

DOM 이벤트 API에서는 사용자 정의 타입을 정의하고 다른 이벤트처럼 처리할 수 있는 기능을 지원한다. 예를 들어 로그인이나 로그아웃, 또는 리스트에 새 레코드를 생성하는 것과 같은 이벤트에 대한 이벤트 핸들러를 생성할 수 있는 것이다.

사용자 정의 이벤트 생성은 아래와 같은 방법으로 할 수 있다.

```js
const EVENT_NAME = 'FiveCharInputValue';
const input = document.querySelector('input');

input.addEventListener('input', () => {
  const { length } = input.value;

  // input의 길이가 5라면 특별 이벤트를 발생시킨다.
  if (length === 5) {
    const time = new Date().getTime();
    // 생성자에서 detail 객체를 사용해 추가 데이터를 핸들러에 전달할 수도 있다.
    const event = new CustomEvent(EVENT_NAME, {
      detail: {
        time,
      },
    });

    input.dispatchEvent(event);
  }
});

// 사용자 정의 이벤트를 처리하기 위해 이벤트 리스너를 추가한다.
input.addEventListener(EVENT_NAME, (e) => {
  console.log(e.detail);
});
```

<br/>

### TodoMVC에 이벤트 추가

관리해야 할 이벤트 목록은 다음과 같다.

> - 항목 삭제: 행의 오른쪽에 있는 십자가를 클릭한다.
> - 항목의 완료 여부 토글: 행의 왼쪽에 있는 원을 클릭한다.
> - 필터 변경: 하단의 필터 이름을 클릭한다.
> - 항목 생성: 상단 입력 텍스트에 값을 입력하고 키보드의 Enter를 누른다.
> - 완성된 모든 항목 삭제: 'Clear completed' 레이블을 클릭한다.
> - 모든 항목의 완료 여부 토글: 왼쪽 상단 모서리에 있는 V자 표시를 클릭한다.
> - 항목 편집: 행을 더블 클릭하고 값을 변경한 후 키보드에서 Enter를 누른다.
