## 렌더링

> 프레임워크 없이 어플리케이션 렌더링 엔진을 만들기

### 렌더링 성능 모니터링

아래의 방법으로 렌더링 성능을 모니터링할 수 있다.

- 크롬 개발자 도구
- stats.js(라이브러리)
- 사용자 정의 성능 모니터 위젯

```js
// 사용자 정의 성능 위젯
// 현재 렌더링 사이클과 다음 사이클 사이의 시간을 추적하여 1초동안 몇 번의 렌더링이 일어나는지 표시하는 위젯

let panel;
let start;
let frames = 0;

const create = () => {
  const div = document.createElement('div');

  div.style.position = 'fixed';
  div.style.left = '0px';
  div.style.top = '0px';
  div.style.width = '50px';
  div.style.height = '50px';
  div.style.backgroundColor = 'black';
  div.style.color = 'white';
};

const tick = () => {
  frames++;

  // 윈도우 컨텍스트에서 탐색이 시작된 시간 또는 Worker 및 ServiceWorker 컨텍스트에서 Worker가 실행된 시간 이후 경과된 시간을 나타낸다.
  const now = window.performance.now;

  // 화면에 표시된지 1초가 경과됐으면 지금까지 계산한 frames를 화면에 표시하고 현재 경과 시간을 start로 초기화한다.
  if (now >= start + 1000) {
    panel.innerText = frames;
    frames = 0;
    start = now;
  }

  // 다음 repaint 직전에 수행할 콜백 함수를 브라우저에게 전달하는 함수. 실행 빈도는 모니터의 주사율과 같다.
  // 다른 탭을 보거나 iframe 안에서 hidden이 될 경우 백그라운드 실행을 멈춘다.
  window.requestAnimationFrame(tick);
};

const init = (parent = document.body) => {
  panel = create();

  window.requestAnimationFrame(() => {
    start = window.performance.now();
    parent.appendChild(panel);
    tick();
  });
};

export default init;
```

<br/>

### 렌더링 함수

> **순수 함수로 요소 렌더링 하기**  
> DOM 요소가 애플리케이션의 상태에만 의존하는 렌더링 함수를 만들어 보자.

#### 1. 문자열을 사용해 요소 렌더링하기

전체 코드는 [여기](https://github.com/Apress/frameworkless-front-end-development/tree/master/Chapter02/01)

TodoMVC 렌더링 함수(view)의 함수를 보자.

```js
// view.js

export default (targetElement, state) => {
  const { currentFilter, todos } = state;

  const element = targetElement.cloneNode(true);

  const list = element.querySelector('.todo-list');
  const counter = element.querySelector('.todo-count');
  const filters = element.querySelector('.filters');

  list.innerHTML = todos.map(getTodoElement).join('');
  counter.textContent = getTodoCount(todos);

  Array.from(filters.querySelectorAll('li a')).forEach((a) => {
    if (a.textContent === currentFilter) {
      a.classList.add('selected');
    } else {
      a.classList.remove('selected');
    }
  });

  return element;
};
```

이 뷰 함수는 기본적으로 `targetElement`를 받아 `cloneNode`를 이용해 복제한다. 그런 다음 변경사항을 적용하여 새로운 노드를 추가 혹은 삭제해 반환한다.

이와 같이 분리된 DOM 요소를 수정하면 성능이 향상된다. 아래는 이 뷰 함수를 실제 DOM에 연결하 하는 간단한 컨트롤러 코드다.

```js
// index.js

import getTodos from './getTodos.js'; // faker.js 라이브러리를 사용해 모킹하는 모듈
import view from './view.js';

const state = {
  todos: getTodos(),
  currentFilter: 'All',
};

const main = document.querySelector('.todoapp');

window.requestAnimationFrame(() => {
  const newMain = view(main, state);
  main.replaceWith(newMain);
});
```

이렇게 작성한 렌더링 엔진은 `requestAnimationFrame`이 사용된다. 나아가 모든 DOM 조작이나 애니메이션은 이 API를 기반으로 해야 한다. `requestAnimationFrame`은 다음과 같은 장점이 있다.

1. 메인 스레드를 차단하지 않으며 다음 repaint가 이벤트 루프에서 스케줄링되기 직전에 실행된다.
2. 이 콜백 내에서 DOM 작업을 수행하면 더 효율적으로 DOM을 조작할 수 있다.

즉 `requestAnimationFrame`에 의해 렌더링 스키마는 다음과 같아진다.

`브라우저 렌더링` -> (requestAnimationFrame) -> `다음 렌더링 대기` -> `새 가상 노드` -> (replaceNode) -> `DOM 조작` -> `브라우저 렌더링`

<br/>

### 코드 리뷰

> 위 예제에서 사용했던 view 코드를 리뷰한다. view에는 다음과 같은 문제가 있다.
>
> - 하나의 거대한 함수. 여러 DOM 요소를 조작하는 함수가 단 하나뿐이다.
> - 일관성 없는 코드. 동일한 작업에 대해 각기 다른 방법으로 코드를 짜고 있다.

따라서 뷰를 좀 더 작은 함수로 나누고 일관성 문제를 해결할 필요가 있다. 변경된 코드는 [여기](https://github.com/Apress/frameworkless-front-end-development/tree/master/Chapter02/02/view)에서 확인 가능하다.

할 일의 수를 보여주는 counterView, 필터를 렌더링하는 filtersView, 리스트를 렌더링하는 todosView로 뷰를 나누고, 이것들을 app view에서 수동으로 호출한다.

<br/>
